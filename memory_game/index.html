<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Memoria de Parejas - 4 Jugadores</title>
    <style>
        :root {
            --bg-color: #f0fdf4;
            --card-back: #4ade80;
            --card-front: #ffffff;
            --text-color: #166534;
            --danna-color: #FF4081;
            /* Pink */
            --yake-color: #2196F3;
            /* Blue */
            --josi-color: #4CAF50;
            /* Green */
            --claret-color: #FF9800;
            /* Orange */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 95vw;
            height: 95vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* --- SCORE BOARD --- */
        header {
            width: 100%;
            display: flex;
            justify-content: space-around;
            padding: 10px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 10px;
            z-index: 10;
        }

        .player-score {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px 15px;
            border-radius: 20px;
            border: 3px solid transparent;
            opacity: 0.6;
            transition: all 0.3s;
            background: white;
        }

        .player-score.active {
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            font-weight: bold;
        }

        .info-col {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .magnets {
            display: flex;
            gap: 2px;
            font-size: 0.8rem;
        }

        .magnet {
            opacity: 0.2;
            filter: grayscale(1);
        }

        .magnet.active {
            opacity: 1;
            filter: grayscale(0);
        }

        /* --- BOARD AREA --- */
        #board-area {
            position: relative;
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        /* --- BUILDER GAME --- */
        #builder-game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        #builder-area {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        #builder-canvas {
            display: grid;
            grid-template-columns: repeat(10, 40px);
            grid-template-rows: repeat(10, 40px);
            gap: 2px;
            background: #eee;
            padding: 10px;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .build-cell {
            width: 40px;
            height: 40px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }

        .build-cell.filled {
            box-shadow: inset 2px 2px 2px rgba(255, 255, 255, 0.6), inset -2px -2px 2px rgba(0, 0, 0, 0.2), 0 4px 0 rgba(0, 0, 0, 0.2);
            border: none;
            border-bottom: 4px solid rgba(0, 0, 0, 0.2);
            position: relative;
            z-index: 1;
            /* Pop out */
            transform: translateY(-2px);
            /* Lift */
        }

        .build-cell.filled::after {
            content: '';
            position: absolute;
            top: 15%;
            left: 15%;
            width: 70%;
            height: 70%;
            border-radius: 50%;
            background: inherit;
            box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3), inset 1px 1px 2px rgba(255, 255, 255, 0.5);
            filter: brightness(1.1);
        }

        #builder-palette {
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: white;
            padding: 10px;
            border-radius: 10px;
        }

        .palette-color {
            width: 40px;
            height: 40px;
            border-radius: 5px;
            cursor: pointer;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-bottom: 4px solid rgba(0, 0, 0, 0.3);
            transition: transform 0.1s;
            box-shadow: inset 2px 2px 2px rgba(255, 255, 255, 0.6), inset -2px -2px 2px rgba(0, 0, 0, 0.2);
            position: relative;
            margin-bottom: 2px;
        }

        .palette-color:active {
            border-bottom-width: 2px;
            transform: translateY(2px);
        }

        .palette-color::after {
            content: '';
            position: absolute;
            top: 20%;
            left: 20%;
            width: 60%;
            height: 60%;
            border-radius: 50%;
            background: inherit;
            box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.3), inset 1px 1px 1px rgba(255, 255, 255, 0.4);
            filter: brightness(1.1);
        }

        .palette-color.selected {
            transform: scale(1.2);
            border-color: #333;
        }

        /* --- GRID --- */
        #card-grid {
            display: grid;
            gap: 15px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 20px;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.05);
            transition: all 0.3s;
        }

        .card {
            width: 140px;
            height: 140px;
            background-color: var(--card-back);
            border-radius: 15px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 4rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.6s cubic-bezier(0.4, 0.0, 0.2, 1), background-color 0.3s;
            position: relative;
            transform-style: preserve-3d;
        }

        .card::before {
            content: '?';
            font-size: 5rem;
            color: rgba(255, 255, 255, 0.6);
            font-weight: 900;
            position: absolute;
            z-index: 1;
        }

        .card.flipped,
        .card.matched {
            background-color: var(--card-front);
            transform: rotateY(180deg);
        }

        .card.flipped::before,
        .card.matched::before {
            display: none;
        }

        .card-content {
            backface-visibility: hidden;
            transform: rotateY(180deg);
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Cursor Highlight */
        .card.highlight {
            outline: 5px solid gold;
            transform: scale(1.05);
            z-index: 5;
        }

        .card.flipped.highlight,
        .card.matched.highlight {
            transform: rotateY(180deg) scale(1.05);
        }

        /* --- OVERLAYS --- */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            display: none !important;
        }

        .card-options {
            display: flex;
            gap: 10px;
            /* Reduced gap */
            margin-top: 5px;
            /* Reduced margin */
            flex-wrap: wrap;
            /* Allow wrapping */
            justify-content: center;
        }

        #player-options {
            max-height: 25vh;
            /* Scrollable list for players */
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 5px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.5);
        }

        .menu-option {
            padding: 10px 20px;
            /* Smaller default */
            font-size: 1.2rem;
            background: white;
            border: 2px solid #ddd;
            border-radius: 10px;
            /* Smaller radius */
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 0 #ccc;
        }

        .menu-option.selected {
            background: var(--yake-color);
            color: white;
            border-color: #1976D2;
            box-shadow: 0 4px 0 #0D47A1;
            transform: translateY(2px);
        }

        .player-toggle.selected {
            transform: translateY(2px);
        }

        #music-toggle {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.7);
            padding: 5px 12px;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            border: 1px solid #ccc;
            font-weight: normal;
            font-size: 0.9rem;
            opacity: 0.5;
            transition: all 0.3s;
        }

        #music-toggle:hover,
        #music-toggle:active {
            opacity: 1;
            background: white;
            transform: scale(1.05);
        }

        #timer-display {
            position: fixed;
            top: auto;
            bottom: 20px;
            right: 20px;
            background: #ff5722;
            color: white;
            padding: 10px 25px;
            border-radius: 50px;
            font-size: 2rem;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            z-index: 150;
            border: 3px solid white;
        }

        /* --- PLAYER CHARACTER (Puppet) --- */
        #player-character {
            position: absolute;
            width: 60px;
            height: 100px;
            pointer-events: none;
            z-index: 50;
            transition: top 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), left 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            filter: drop-shadow(0 5px 5px rgba(0, 0, 0, 0.3));
        }

        .doll-svg-container {
            width: 100%;
            height: 100%;
        }

        .walking {
            animation: bounce 0.3s infinite alternate;
        }

        @keyframes bounce {
            from {
                transform: translateY(0);
            }

            to {
                transform: translateY(-10px);
            }
        }

        .music-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 101;
        }

        .btn-icon {
            display: inline-block;
            width: 24px;
            height: 24px;
            line-height: 24px;
            text-align: center;
            border-radius: 50%;
            background: #333;
            color: white;
            font-weight: bold;
            font-size: 0.8rem;
            margin: 0 5px;
        }

        .btn-x {
            background: #3b82f6;
        }

        /* PS X - Blue */
        .btn-t {
            background: #10b981;
        }

        /* PS Triangle - Green used here for Practice */

        #gamepad-hint {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 30px;
            font-size: 0.9rem;
            z-index: 200;
            border: 2px solid white;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bad-anim {
            animation: shake 0.5s infinite;
        }

        @keyframes shake {
            0% {
                transform: translate(1px, 1px) rotate(0deg);
            }

            10% {
                transform: translate(-1px, -2px) rotate(-1deg);
            }

            20% {
                transform: translate(-3px, 0px) rotate(1deg);
            }

            30% {
                transform: translate(3px, 2px) rotate(0deg);
            }

            40% {
                transform: translate(1px, -1px) rotate(1deg);
            }

            50% {
                transform: translate(-1px, 2px) rotate(-1deg);
            }

            60% {
                transform: translate(-3px, 1px) rotate(0deg);
            }

            70% {
                transform: translate(3px, 1px) rotate(-1deg);
            }

            80% {
                transform: translate(-1px, -1px) rotate(1deg);
            }

            90% {
                transform: translate(1px, 2px) rotate(0deg);
            }

            100% {
                transform: translate(1px, -2px) rotate(-1deg);
            }
        }

        .pop-anim {
            animation: pop 0.3s ease-in-out;
        }

        @keyframes pop {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.3);
            }

            100% {
                transform: scale(1);
            }
        }

        /* Responsive Portrait */
        @media (orientation: portrait) {
            h1 {
                font-size: 1.5rem;
                margin: 5px 0;
            }

            h2 {
                font-size: 1rem;
                margin: 5px 0;
                color: #333;
            }

            .card {
                width: 100%;
                height: auto;
                aspect-ratio: 1;
                font-size: 8vw;
                /* Dynamic font size */
                display: flex;
                justify-content: center;
                align-items: center;
            }

            #card-grid {
                gap: 2vw;
                /* Dynamic gap */
                padding: 10px;
                width: 100%;
                box-sizing: border-box;
                align-content: center;
            }

            .menu-option {
                padding: 10px 15px;
                font-size: 1rem;
                touch-action: manipulation;
            }

            #player-options {
                max-height: 20vh;
                /* Slightly more space */
                margin-bottom: 10px;
            }

            #card-options {
                position: relative;
                z-index: 50;
            }

            #start-screen {
                justify-content: flex-start;
                padding-top: 10px;
                padding-bottom: 50px;
                /* Extra space at bottom */
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            #action-section {
                margin-top: 10px !important;
                margin-bottom: 20px;
            }

            /* Horizontal Scoreboard for Mobile */
            #score-board {
                flex-direction: row;
                flex-wrap: wrap;
                width: 100%;
                justify-content: center;
                gap: 5px;
                padding: 5px;
                margin-bottom: 5px;
            }

            .player-score {
                width: auto;
                flex: 1 1 40%;
                /* Grow to fill */
                padding: 5px;
                margin-bottom: 0;
                flex-direction: row;
                align-items: center;
                border-width: 1px;
            }

            .player-score .avatar {
                width: 25px !important;
                height: 25px !important;
                margin-bottom: 0;
                margin-right: 5px;
            }

            .player-score .info-col {
                text-align: left;
                display: flex;
                flex-direction: column;
                justify-content: center;
            }

            .player-score .name {
                font-size: 0.8rem;
                line-height: 1;
            }

            .player-score .score {
                font-size: 0.75rem;
                line-height: 1;
            }

            .player-score .magnets {
                display: none;
            }

            /* Hide magnets on mobile */

            .player-score .magnets {
                font-size: 0.8rem;
                letter-spacing: -2px;
            }

            #player-character {
                width: 40px;
                height: 70px;
            }

            #gamepad-hint {
                display: none !important;
            }
        }

        /* --- MAIN MENU HUB --- */
        .game-wrapper {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: absolute;
            top: 0;
            left: 0;
            background-color: var(--bg-color);
            transition: opacity 0.5s;
        }

        .hidden {
            display: none !important;
        }

        #main-menu {
            background: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
            z-index: 2000;
        }

        .main-title {
            font-size: 3rem;
            color: #FF4081;
            text-shadow: 2px 2px #fff;
            margin-bottom: 2rem;
            text-align: center;
        }

        .game-selection {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            width: 90%;
            max-width: 600px;
        }

        .game-card {
            background: white;
            border-radius: 20px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 4px solid transparent;
        }

        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.15);
            border-color: var(--yake-color);
        }

        .game-card:active {
            transform: scale(0.95);
        }

        .game-card .icon {
            font-size: 4rem;
            margin-bottom: 10px;
        }

        .game-card .title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #555;
        }

        /* Generic Back Button */
        #back-to-menu {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3000;
            background: #FF5722;
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            display: none;
            /* Controlled by JS */
        }

        /* Game Specific Wrappers handled by ID */
        #memory-game-wrapper {
            overflow: hidden;
            /* For memory game scrolling issues */
        }

        /* --- SIMON GAME --- */
        #simon-board {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            padding: 15px;
            background: #222;
            border-radius: 50%;
            width: 300px;
            height: 300px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            position: relative;
        }

        .simon-btn {
            width: 100%;
            height: 100%;
            cursor: pointer;
            opacity: 0.5;
            transition: all 0.1s;
            border: none;
        }

        .simon-btn:active,
        .simon-btn.active {
            opacity: 1;
            transform: scale(0.98);
            filter: brightness(1.5);
        }

        .simon-btn.green {
            background-color: #4CAF50;
            border-top-left-radius: 100%;
        }

        .simon-btn.red {
            background-color: #F44336;
            border-top-right-radius: 100%;
        }

        .simon-btn.yellow {
            background-color: #FFEB3B;
            border-bottom-left-radius: 100%;
        }

        .simon-btn.blue {
            background-color: #2196F3;
            border-bottom-right-radius: 100%;
        }

        /* --- WHACK GAME --- */
        #whack-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            width: 320px;
            height: 320px;
            background: #AED581;
            /* Light Grass */
            padding: 20px;
            border-radius: 30px;
            border: 8px solid #7CB342;
            box-shadow: 0 15px 0 #558B2F, inset 0 10px 20px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .hole {
            background: #5D4037;
            /* Dirt */
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            border: 5px solid #8D6E63;
            box-shadow: inset 0 10px 15px rgba(0, 0, 0, 0.5);
            transition: all 0.1s;
        }

        .hole:active {
            transform: scale(0.95);
        }

        .mole {
            width: 70%;
            height: 90%;
            position: absolute;
            bottom: -100%;
            /* Hidden */
            left: 15%;
            transition: bottom 0.1s;
            cursor: pointer;
            pointer-events: none;
            /* Only Clickable when up */
        }

        .mole.up {
            bottom: -10px;
            pointer-events: auto;
        }

        /* Mole Appearance override to be dynamic via JS, but base */
        .mole-svg-container {
            width: 100%;
            height: 100%;
        }

        /* --- DRESS GAME --- */
        #dress-controls {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 40%;
            max-width: 300px;
            height: 90vh;
            overflow-y: auto;
        }

        .dress-category h3 {
            margin: 0 0 5px 0;
            font-size: 0.9rem;
            color: #880E4F;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .dress-options {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .dress-btn {
            background: #f8bbd0;
            border-radius: 8px;
            padding: 8px 2px;
            font-size: 1.2rem;
            cursor: pointer;
            border: 2px solid transparent;
            text-align: center;
            transition: transform 0.1s;
        }

        .dress-btn:active {
            transform: scale(0.9);
        }

        .dress-btn:hover {
            background: #F48FB1;
        }

        #dress-canvas {
            width: 55%;
            height: 90vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle, #FCE4EC 0%, #F8BBD0 100%);
            border-radius: 20px;
            border: 4px dashed #EC407A;
        }

        #mannequin {
            height: 95%;
            width: auto;
            filter: drop-shadow(0 5px 5px rgba(0, 0, 0, 0.1));
        }

        @media (orientation: portrait) {
            #dress-game-wrapper {
                flex-direction: column !important;
                justify-content: flex-start !important;
            }

            #dress-controls {
                width: 100%;
                height: 35vh;
                order: 2;
                max-width: none;
            }

            #dress-canvas {
                width: 100%;
                height: 50vh;
                order: 1;
                margin-bottom: 10px;
            }

            .dress-options {
                display: flex;
                overflow-x: auto;
                padding-bottom: 5px;
            }

            .dress-btn {
                min-width: 40px;
            }

            .main-title {
                font-size: 2rem;
                margin-top: 20px;
            }

            .game-card .icon {
                font-size: 3rem;
            }

            .game-card .title {
                font-size: 1.2rem;
            }

            .game-selection {
                gap: 10px;
            }
        }
    </style>
</head>

<body>
    <!-- MENU -->
    <div id="main-menu" class="game-wrapper">
        <h1 class="main-title">üåü Arcade de Esparche üåü</h1>
        <div class="game-selection">
            <div class="game-card" onclick="openGame('MEMORY')">
                <div class="icon">üÉè</div>
                <div class="title">Memoria</div>
            </div>
            <div class="game-card" onclick="openGame('SIMON')">
                <div class="icon">üéπ</div>
                <div class="title">Sim√≥n Dice</div>
            </div>
            <div class="game-card" onclick="openGame('WHACK')">
                <div class="icon">üî®</div>
                <div class="title">Atrapa</div>
            </div>
            <div class="game-card" onclick="openGame('BUILDER')">
                <div class="icon">üèóÔ∏è</div>
                <div class="title">Constructor</div>
            </div>

        </div>
    </div>

    <button id="back-to-menu" onclick="goToMainMenu()">üè† Men√∫</button>

    <!-- WRAPPER: BUILDER -->
    <div id="builder-game-wrapper" class="game-wrapper hidden">
        <h1 class="main-title" style="margin-top: 10px; font-size: 2rem;">üèóÔ∏è Arquitecto Lego</h1>

        <!-- Blueprint Controls -->
        <div id="blueprint-controls"
            style="display: flex; gap: 10px; align-items: center; margin-top: 10px; background: rgba(255,255,255,0.8); padding: 10px; border-radius: 15px;">
            <button onclick="prevBlueprint()" class="menu-option" style="padding: 5px 15px;">‚óÄ</button>
            <div style="text-align: center;">
                <h3 id="blueprint-name" style="margin:0; font-size: 1.2rem;">Libre</h3>
                <div id="blueprint-preview"
                    style="width: 150px; height: 150px; display: grid; grid-template-columns: repeat(10, 1fr); grid-template-rows: repeat(10, 1fr); gap: 1px; background: #eee; border: 4px solid #333; margin: 5px auto; box-shadow: 0 4px 8px rgba(0,0,0,0.2);">
                </div>
            </div>
            <button onclick="nextBlueprint()" class="menu-option" style="padding: 5px 15px;">‚ñ∂</button>
        </div>

        <div id="builder-area">
            <div id="builder-palette">
                <!-- Generated by JS -->
            </div>
            <div id="builder-canvas">
                <!-- Generated by JS -->
            </div>
        </div>

        <div style="margin-top: 20px; display:flex; gap: 20px;">
            <button onclick="clearBuilder()" class="menu-option" style="background: #ef4444; color: white;">üß®
                Borrar Todo</button>
            <button onclick="checkBlueprint()" class="menu-option" style="background: #3b82f6; color: white;">‚úÖ
                Comprobar</button>
        </div>
        <p id="builder-msg" style="margin-top:10px; height: 20px;"></p>
    </div>

    <!-- WRAPPER: MEMORY (Existing) -->
    <div id="memory-game-wrapper" class="game-wrapper hidden">
        <div id="game-container">
            <!-- Header: Jugadores -->
            <header id="score-board">
                <!-- Generado din√°micamente -->
            </header>

            <!-- Bot√≥n M√∫sica -->
            <button id="music-toggle" class="music-btn">üîá M√∫sica</button>

            <!-- Audio Musica -->
            <audio id="bg-music" loop>
                <source src="music.mp3" type="audio/mpeg">
            </audio>

            <!-- √Årea de Juego -->
            <div id="board-area">
                <div id="card-grid"></div>
                <div id="timer-display" class="hidden">30</div>
            </div>

            <!-- Men√∫ Inicial -->
            <div id="start-screen" class="overlay">
                <h1>¬°Memoria de Parejas!</h1>

                <!-- Selector de Jugadores -->
                <div style="margin-bottom: 20px; width: 90%; max-width: 800px;">
                    <h2>Jugadores:</h2>
                    <div id="player-options" class="card-options">
                        <!-- Generado din√°micamente por renderPlayerOptions() -->
                    </div>
                </div>

                <!-- Selector de Tema -->
                <div style="margin-bottom: 20px;">
                    <h2>Elige Cartas:</h2>
                    <div id="theme-options" class="card-options">
                        <div class="menu-option theme-opt selected" data-value="ANIMALS"
                            onclick="selectTheme('ANIMALS')">üê∂
                            Animales</div>
                        <div class="menu-option theme-opt" data-value="FACES" onclick="selectTheme('FACES')">üòä Caritas
                        </div>
                        <div class="menu-option theme-opt" data-value="FRUITS" onclick="selectTheme('FRUITS')">üçé Frutas
                        </div>
                        <div class="menu-option theme-opt" data-value="VEHICLES" onclick="selectTheme('VEHICLES')">üöó
                            Veh√≠culos</div>
                        <div class="menu-option theme-opt" data-value="JOBS" onclick="selectTheme('JOBS')">üë©‚Äç‚öïÔ∏è Oficios
                        </div>
                        <div class="menu-option theme-opt" data-value="CLOTHES" onclick="selectTheme('CLOTHES')">üëï Ropa
                        </div>
                        <div class="menu-option theme-opt" data-value="SPORTS" onclick="selectTheme('SPORTS')">‚öΩ
                            Deportes
                        </div>
                    </div>
                </div>

                <!-- Selector de Cantidad -->
                <div style="margin-bottom: 20px;">
                    <h2>Cantidad de Cartas:</h2>
                    <div id="card-options" class="card-options">
                        <div class="menu-option selected" data-value="12" onclick="updateMenuSelection(12)">12</div>
                        <div class="menu-option" data-value="16" onclick="updateMenuSelection(16)">16</div>
                        <div class="menu-option" data-value="20" onclick="updateMenuSelection(20)">20</div>
                        <div class="menu-option" data-value="24" onclick="updateMenuSelection(24)">24</div>
                    </div>
                </div>

                <!-- Boton Jugar -->
                <div id="action-section" style="margin-top: 30px;">
                    <div class="menu-option"
                        style="background:#4ade80; color:#065f46; font-weight:bold; padding: 15px 50px;"
                        onclick="startGame()">
                        ¬°JUGAR! ‚ñ∂Ô∏è
                    </div>
                </div>

                <p style="font-size: 0.9rem; opacity: 0.8; margin-top:20px">
                    Usa el mando üéÆ o t√°ctil üëÜ
                </p>
            </div>

            <!-- Pantalla Fin de Juego -->
            <div id="game-over-screen" class="overlay hidden">
                <h1 id="winner-display" style="font-size: 3rem; margin-bottom: 20px;"></h1>
                <div id="final-scores" style="font-size: 1.5rem; margin-bottom: 30px;"></div>

                <!-- Mobile Button -->
                <div onclick="resetGame()" class="menu-option"
                    style="margin-bottom: 20px; background: #4ade80; color: #065f46; font-weight: bold; padding: 15px 30px;">
                    üîÑ Jugar Otra Vez
                </div>

                <div style="font-size: 1.2rem; opacity: 0.7;">
                    (O presiona <span style="background:#333; color:white; padding:2px 8px; border-radius:50%">√ó</span>
                    en el mando)
                </div>
            </div> <!-- End game-over-screen -->

            <div id="gamepad-hint" style="display:none !important"></div>
        </div> <!-- End game-container -->
    </div> <!-- End memory-game-wrapper -->

    <!-- SIMON SAYS WRAPPER -->
    <div id="simon-game-wrapper" class="game-wrapper hidden">
        <h1 class="main-title">üéπ Sim√≥n Dice üéπ</h1>

        <div id="simon-status" style="font-size: 1.5rem; margin-bottom: 20px; height: 30px;">Presiona Jugar
        </div>

        <div id="simon-board">
            <div class="simon-btn green" data-color="0" onclick="handleSimonInput(0)"></div>
            <div class="simon-btn red" data-color="1" onclick="handleSimonInput(1)"></div>
            <div class="simon-btn yellow" data-color="2" onclick="handleSimonInput(2)"></div>
            <div class="simon-btn blue" data-color="3" onclick="handleSimonInput(3)"></div>
        </div>

        <div style="margin-top: 30px; display: flex; gap: 20px;">
            <button onclick="startSimonGame()" class="menu-option"
                style="background:#2196F3; color: white; font-weight:bold;">‚ñ∂Ô∏è Jugar</button>
            <button onclick="goToMainMenu()" class="menu-option">üè† Salir</button>
        </div>
    </div>
    </div>

    <!-- WHACK WRAPPER -->
    <div id="whack-game-wrapper" class="game-wrapper hidden">
        <h1 class="main-title">üî® Atrapa al Mu√±eco üî®</h1>

        <div style="display:flex; gap:20px; font-size:1.5rem; margin-bottom:10px;">
            <div>Puntos: <span id="whack-score">0</span></div>
            <div>Tiempo: <span id="whack-timer">30</span>s</div>
        </div>

        <div id="whack-grid">
            <!-- 9 Holes -->
            <div class="hole" data-id="0">
                <div class="mole"></div>
            </div>
            <div class="hole" data-id="1">
                <div class="mole"></div>
            </div>
            <div class="hole" data-id="2">
                <div class="mole"></div>
            </div>
            <div class="hole" data-id="3">
                <div class="mole"></div>
            </div>
            <div class="hole" data-id="4">
                <div class="mole"></div>
            </div>
            <div class="hole" data-id="5">
                <div class="mole"></div>
            </div>
            <div class="hole" data-id="6">
                <div class="mole"></div>
            </div>
            <div class="hole" data-id="7">
                <div class="mole"></div>
            </div>
            <div class="hole" data-id="8">
                <div class="mole"></div>
            </div>
        </div>

        <div style="margin-top: 20px; display: flex; gap: 20px;">
            <button onclick="startWhackGame()" class="menu-option"
                style="background:#FF9800; color: white; font-weight:bold;">‚ñ∂Ô∏è Jugar</button>
            <button onclick="goToMainMenu()" class="menu-option">üè† Salir</button>
        </div>
    </div>



    </div>




    </div>
    </div>

    <script>
        // --- MAIN MENU NAVIGATION ---
        let APP_MODE = 'MENU'; // MENU, MEMORY, SIMON, WHACK, RACE
        // Functions defined below (see NAVIGATION section)

        // --- CONFIGURACI√ìN & ESTADO ---
        const PLAYERS_DEFAULT = [
            { name: "Danna", color: "#FF4081", id: 0, magnets: 0, score: 0, wins: 0 },
            { name: "Yake", color: "#2196F3", id: 1, magnets: 0, score: 0, wins: 0 },
            { name: "Josi", color: "#4CAF50", id: 2, magnets: 0, score: 0, wins: 0 },
            { name: "Clairet", color: "#FF9800", id: 3, magnets: 0, score: 0, wins: 0 },
            { name: "Pas", color: "#00BCD4", id: 4, magnets: 0, score: 0, wins: 0 },
            { name: "Ingrid", color: "#9C27B0", id: 5, magnets: 0, score: 0, wins: 0 },
            { name: "Gabi", color: "#009688", id: 6, magnets: 0, score: 0, wins: 0 },
            { name: "Valeria", color: "#E91E63", id: 7, magnets: 0, score: 0, wins: 0 },
            { name: "Vito", color: "#3F51B5", id: 8, magnets: 0, score: 0, wins: 0 },
            { name: "Gito", color: "#795548", id: 9, magnets: 0, score: 0, wins: 0 },
            { name: "Belen", color: "#E040FB", id: 10, magnets: 0, score: 0, wins: 0 },
            { name: "Jelany", color: "#FFC107", id: 11, magnets: 0, score: 0, wins: 0 },
            { name: "Isaac", color: "#673AB7", id: 12, magnets: 0, score: 0, wins: 0 },
            { name: "Jennifer", color: "#8BC34A", id: 13, magnets: 0, score: 0, wins: 0 },
            { name: "Beatriz", color: "#FF5722", id: 14, magnets: 0, score: 0, wins: 0 }
        ];

        // Cargar victorias guardadas
        const savedWinsRaw = JSON.parse(localStorage.getItem('memory_game_wins')) || [];
        const savedWins = PLAYERS_DEFAULT.map((_, i) => savedWinsRaw[i] || 0);

        const PLAYERS = PLAYERS_DEFAULT.map((p, i) => ({ ...p, wins: savedWins[i] || 0 }));
        let activePlayers = []; // Determined at start

        function saveWins() {
            localStorage.setItem('memory_game_wins', JSON.stringify(PLAYERS.map(p => p.wins)));
        }

        const EMOJIS_FACES = ['üòÄ', 'üòÇ', 'üòç', 'üòé', 'üò°', 'üò±', 'ü§î', 'üò¥', 'ü§°', 'üëª', 'üëΩ', 'ü§ñ'];
        const EMOJIS_FRUITS = ['üçé', 'üçå', 'üçá', 'üçâ', 'üçì', 'üçí', 'üçç', 'ü•ù', 'ü•ë', 'ü••', 'üçä', 'üçã'];
        const EMOJIS_VEHICLES = ['üöó', 'üöå', 'üöë', 'üöì', 'üöí', 'üöú', 'üö≤', 'üõ¥', 'üõµ', 'üöÇ', 'üöÅ', 'üöÄ'];
        const EMOJIS_JOBS = ['üëÆ', 'üë∑', 'üíÇ', 'üïµÔ∏è', 'üë©‚Äç‚öïÔ∏è', 'üë®‚Äçüåæ', 'üë©‚Äçüç≥', 'üë©‚Äçüé§', 'üë©‚Äçüé®', 'üë©‚ÄçüöÄ', 'üë®‚Äçüöí', 'üßô'];
        const EMOJIS_CLOTHES = ['üëï', 'üëñ', 'üëó', 'üëò', 'üëô', 'üëö', 'üëõ', 'üëú', 'üëû', 'üëü', 'üß¢', 'üé©'];
        const EMOJIS_SPORTS = ['‚öΩ', 'üèÄ', 'üèà', '‚öæ', 'üéæ', 'üèê', 'üèâ', 'üé±', 'üèì', 'üè∏', 'ü•ä', 'ü•ã'];
        const EMOJIS_ANIMALS = ['üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê®', 'üêØ', 'ü¶Å', 'üêÆ'];

        // --- AVATAR GENERATOR (SVG) ---
        function getAvatarSVG(name, isBad = false) {
            const smile = isBad
                ? '<path d="M 35 75 Q 50 85 65 75" stroke="#333" stroke-width="3" fill="none" class="mouth-bad" />'
                : '<path d="M 35 70 Q 50 85 65 70" stroke="#333" stroke-width="3" fill="none" />';

            const eyes = isBad
                ? '<circle cx="35" cy="55" r="4" fill="#333"/><circle cx="65" cy="55" r="4" fill="#333"/><path d="M25 45 L45 50 M75 45 L55 50" stroke="#333" stroke-width="2"/>'
                : '<circle cx="35" cy="55" r="5" fill="#333"/><circle cx="65" cy="55" r="5" fill="#333"/>';

            // Generic Generator with specific overrides
            let body = '';

            // Definiendo estilos espec√≠ficos brevemente
            if (name === 'Danna') {
                body = `
                <circle cx="50" cy="50" r="30" fill="#FFCCBC" />
                <path d="M 15 50 Q 50 10 85 50" fill="#5D4037" />
                <circle cx="20" cy="50" r="10" fill="#5D4037" />
                <circle cx="80" cy="50" r="10" fill="#5D4037" />
                 <rect x="30" y="80" width="40" height="40" rx="10" fill="#E91E63" />
                <circle cx="50" cy="95" r="8" fill="#F8BBD0" />
                 <rect x="35" y="120" width="12" height="25" fill="#333" />
                <rect x="53" y="120" width="12" height="25" fill="#333" />`;
            } else if (name === 'Yake') {
                body = `
                <circle cx="50" cy="50" r="30" fill="#FFCCBC" />
                 <path d="M 20 45 Q 50 0 80 45" fill="#1A237E" />
                 <rect x="30" y="80" width="40" height="40" rx="10" fill="#2196F3" />
                 <polygon points="40,85 50,105 60,85" fill="#1565C0" />
                 <rect x="35" y="120" width="12" height="25" fill="#333" />
                <rect x="53" y="120" width="12" height="25" fill="#333" />`;
            } else if (name === 'Josi') {
                body = `
                <circle cx="50" cy="50" r="30" fill="#FFCCBC" />
                <path d="M 20 50 Q 50 15 80 50" fill="#4E342E" />
                <rect x="30" y="80" width="40" height="40" rx="10" fill="#4CAF50" />
                 <line x1="30" y1="90" x2="70" y2="90" stroke="#388E3C" stroke-width="3" />
                 <rect x="35" y="120" width="12" height="25" fill="#333" />
                <rect x="53" y="120" width="12" height="25" fill="#333" />`;
            } else if (name === 'Clairet') {
                body = `
                <circle cx="50" cy="50" r="30" fill="#FFCCBC" />
                <path d="M 15 50 Q 10 30 30 20 Q 50 10 70 20 Q 90 30 85 50" fill="#FFD54F" /> 
                <circle cx="20" cy="50" r="10" fill="#FFD54F" />
                <circle cx="80" cy="50" r="10" fill="#FFD54F" />
                <rect x="30" y="80" width="40" height="40" rx="10" fill="#FF9800" />
                <circle cx="50" cy="100" r="5" fill="#FFF" />
                <rect x="35" y="120" width="12" height="25" fill="#5D4037" />
                <rect x="53" y="120" width="12" height="25" fill="#5D4037" />
                 <ellipse cx="41" cy="145" rx="7" ry="4" fill="#E65100" /> 
                <ellipse cx="59" cy="145" rx="7" ry="4" fill="#E65100" />`;
            } else {
                // Fallback / New Players
                const p = PLAYERS.find(pl => pl.name === name) || { color: '#999' };
                const c = p.color;
                body = `
                <circle cx="50" cy="50" r="30" fill="#FFCCBC" />
                <path d="M 20 50 Q 50 10 80 50" fill="${c}" opacity="0.8" />
                <rect x="30" y="80" width="40" height="40" rx="10" fill="${c}" />
                <circle cx="50" cy="100" r="8" fill="#FFF" opacity="0.5" />
                <rect x="35" y="120" width="12" height="25" fill="#333" />
                <rect x="53" y="120" width="12" height="25" fill="#333" />`;
            }

            return `<svg viewBox="0 0 100 150" class="player-svg ${isBad ? 'bad-anim' : ''}">
                ${body}
                ${eyes}
                ${smile}
            </svg>`;
        }

        const SFX = {
            select: () => { const o = new AudioContext(); const g = o.createGain(); const osc = o.createOscillator(); osc.type = 'sine'; osc.frequency.setValueAtTime(440, o.currentTime); osc.frequency.exponentialRampToValueAtTime(880, o.currentTime + 0.1); g.gain.setValueAtTime(0.1, o.currentTime); g.gain.exponentialRampToValueAtTime(0.01, o.currentTime + 0.1); osc.connect(g); g.connect(o.destination); osc.start(); osc.stop(o.currentTime + 0.1); },
            error: () => { const o = new AudioContext(); const g = o.createGain(); const osc = o.createOscillator(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, o.currentTime); osc.frequency.linearRampToValueAtTime(100, o.currentTime + 0.2); g.gain.setValueAtTime(0.2, o.currentTime); g.gain.linearRampToValueAtTime(0.01, o.currentTime + 0.2); osc.connect(g); g.connect(o.destination); osc.start(); osc.stop(o.currentTime + 0.2); },
            match: () => { const o = new AudioContext(); const g = o.createGain(); const osc = o.createOscillator(); osc.type = 'triangle'; osc.frequency.setValueAtTime(523.25, o.currentTime); osc.frequency.setValueAtTime(659.25, o.currentTime + 0.1); osc.frequency.setValueAtTime(783.99, o.currentTime + 0.2); g.gain.setValueAtTime(0.1, o.currentTime); g.gain.linearRampToValueAtTime(0, o.currentTime + 0.4); osc.connect(g); g.connect(o.destination); osc.start(); osc.stop(o.currentTime + 0.4); },
            move: () => { const o = new AudioContext(); const g = o.createGain(); const osc = o.createOscillator(); osc.type = 'sine'; osc.frequency.setValueAtTime(300, o.currentTime); osc.frequency.linearRampToValueAtTime(200, o.currentTime + 0.05); g.gain.setValueAtTime(0.05, o.currentTime); g.gain.linearRampToValueAtTime(0, o.currentTime + 0.05); osc.connect(g); g.connect(o.destination); osc.start(); osc.stop(o.currentTime + 0.05); },
            win: () => { const o = new AudioContext(); const g = o.createGain(); const osc = o.createOscillator(); osc.type = 'square'; osc.frequency.setValueAtTime(400, o.currentTime); osc.frequency.linearRampToValueAtTime(800, o.currentTime + 0.5); g.gain.setValueAtTime(0.1, o.currentTime); g.gain.linearRampToValueAtTime(0, o.currentTime + 1.0); osc.connect(g); g.connect(o.destination); osc.start(); osc.stop(o.currentTime + 1.0); }
        };

        const STATE = { MENU: 0, MEMORIZE: 1, PLAY: 2, GAME_OVER: 3, SIMON: 4, WHACK: 5, HUB: 6, BUILDER: 7 };
        let currentState = STATE.HUB;

        let hubSelectionIndex = 0;


        let cardCount = 12;
        let currentTheme = 'ANIMALS';

        let selectedPlayerIds = [0, 1, 2, 3]; // Default active
        let playerFocusIndex = 0;
        let menuSection = 0; // 0: Players, 1: Theme, 2: Count, 3: Start

        let currentPlayerIndex = 0;
        let cards = [];
        let selectedCards = [];
        let isLocked = false;
        let cursorIndex = 0;
        let gridCols = 4;
        let gridRows = 3;

        // --- MUSIC CONTROL ---
        const bgMusic = document.getElementById('bg-music');
        const musicBtn = document.getElementById('music-toggle');
        let musicPlaying = false;

        musicBtn.onclick = () => {
            if (musicPlaying) {
                bgMusic.pause();
                musicBtn.textContent = 'üîá M√∫sica';
            } else {
                bgMusic.play().then(() => {
                    musicBtn.textContent = 'üîä M√∫sica';
                }).catch(e => console.log("Audio play failed interaction required"));
            }
            musicPlaying = !musicPlaying;
        };

        // --- MENU LOGIC ---
        function renderPlayerOptions() {
            const container = document.getElementById('player-options');
            if (!container) return;
            container.innerHTML = '';
            PLAYERS.forEach(p => {
                const el = document.createElement('div');
                el.className = 'menu-option player-toggle';
                if (selectedPlayerIds.includes(p.id)) el.classList.add('selected');
                el.dataset.id = p.id;
                el.textContent = p.name;

                el.style.padding = "10px 15px";
                el.style.borderRadius = "10px";
                el.style.fontSize = "1rem";
                el.style.cursor = "pointer";
                el.style.transition = "transform 0.2s";
                el.style.minWidth = "80px";
                el.style.textAlign = "center";

                if (selectedPlayerIds.includes(p.id)) {
                    el.style.backgroundColor = p.color;
                    el.style.color = '#fff';
                    el.style.border = `2px solid #fff`;
                    el.style.boxShadow = `0 4px 6px ${p.color}`;
                } else {
                    el.style.backgroundColor = '#f3f4f6';
                    el.style.color = '#6b7280';
                    el.style.border = '2px solid transparent';
                    el.style.boxShadow = 'none';
                }

                el.onclick = () => togglePlayer(p.id);
                container.appendChild(el);
            });
        }

        function updateMenuVisuals() {
            const sections = ['player-options', 'theme-options', 'card-options', 'action-section'];

            sections.forEach((id, idx) => {
                const el = document.getElementById(id);
                if (el) {
                    const parent = id === 'action-section' ? el : el.parentElement;

                    if (menuSection === idx) {
                        parent.style.border = "3px solid var(--yake-color)";
                        parent.style.borderRadius = "15px";
                        parent.style.padding = "10px";
                        parent.style.transition = "all 0.2s";
                    } else {
                        parent.style.border = "3px solid transparent";
                    }
                }
            });

            if (menuSection === 0) updatePlayerFocusVisuals();
        }

        function updatePlayerFocusVisuals() {
            document.querySelectorAll('.player-toggle').forEach((el, idx) => {
                if (idx === playerFocusIndex && menuSection === 0) {
                    el.style.transform = "scale(1.15)";
                    el.style.zIndex = "10";
                    el.style.borderColor = "#333";
                } else {
                    el.style.transform = "scale(1)";
                    el.style.zIndex = "1";
                    if (!el.classList.contains('selected')) el.style.borderColor = "transparent";
                }
            });

            // Auto-scroll
            const focusedEl = document.querySelectorAll('.player-toggle')[playerFocusIndex];
            if (focusedEl) focusedEl.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
        }

        function togglePlayer(id) {
            id = parseInt(id);
            const idx = selectedPlayerIds.indexOf(id);
            if (idx > -1) {
                if (selectedPlayerIds.length <= 2) {
                    SFX.error();
                    return;
                }
                selectedPlayerIds.splice(idx, 1);
            } else {
                selectedPlayerIds.push(id);
            }
            SFX.select();
            renderPlayerOptions();
            updatePlayerFocusVisuals();
        }

        function handlePlayerSectionMove(dx) {
            const oldFocus = playerFocusIndex;
            if (dx > 0) playerFocusIndex = Math.min(PLAYERS.length - 1, playerFocusIndex + 1);
            if (dx < 0) playerFocusIndex = Math.max(0, playerFocusIndex - 1);

            if (oldFocus !== playerFocusIndex) {
                SFX.move();
                updatePlayerFocusVisuals();
            }
        }

        function handleMenuInput(type, dx, dy) {
            if (type === 'move') {
                if (Math.abs(dy) > Math.abs(dx)) {
                    // Vertical Move
                    const oldSection = menuSection;
                    if (dy > 0) menuSection = Math.min(3, menuSection + 1);
                    if (dy < 0) menuSection = Math.max(0, menuSection - 1);

                    if (oldSection !== menuSection) {
                        SFX.move();
                        updateMenuVisuals();
                    }
                } else if (Math.abs(dx) > Math.abs(dy)) {
                    // Horizontal Move
                    const move = dx;
                    if (menuSection === 0) {
                        handlePlayerSectionMove(move);
                    } else if (menuSection === 1) {
                        const themes = ['ANIMALS', 'FACES', 'FRUITS', 'VEHICLES', 'JOBS', 'CLOTHES', 'SPORTS'];
                        let idx = themes.indexOf(currentTheme);
                        if (move > 0) idx = (idx + 1) % themes.length;
                        if (move < 0) idx = (idx - 1 + themes.length) % themes.length;
                        selectTheme(themes[idx]);
                    } else if (menuSection === 2) {
                        const options = [12, 16, 20, 24];
                        let idx = options.indexOf(cardCount);
                        if (move > 0) idx = Math.min(options.length - 1, idx + 1);
                        if (move < 0) idx = Math.max(0, idx - 1);
                        updateMenuSelection(options[idx]);
                    }
                }
            }

            if (type === 'action') {
                if (menuSection === 0) {
                    const el = document.querySelectorAll('.player-toggle')[playerFocusIndex];
                    if (el) togglePlayer(el.dataset.id);
                } else if (menuSection === 3) {
                    SFX.select();
                    startGame();
                } else {
                    SFX.select();
                }
            }
        }

        function updateMenuSelection(val) {
            cardCount = val;
            document.querySelectorAll('#card-options .menu-option').forEach(el => {
                el.classList.toggle('selected', parseInt(el.dataset.value) === cardCount);
            });
            // SFX handled by input loop
        }

        function selectTheme(theme) {
            currentTheme = theme;
            document.querySelectorAll('.theme-opt').forEach(el => {
                el.classList.toggle('selected', el.dataset.value === currentTheme);
            });
            SFX.select();
        }

        // --- GAME CONTROL ---
        function startGame() {
            if (selectedPlayerIds.length < 2) {
                alert("Selecciona al menos 2 jugadores.");
                return;
            }

            currentState = STATE.MEMORIZE;
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('gamepad-hint').classList.add('hidden');

            // Configurar jugadores activos
            activePlayers = PLAYERS.filter(p => selectedPlayerIds.includes(p.id));

            // Reset scores
            activePlayers.forEach(p => { p.score = 0; p.magnets = 0; });

            currentPlayerIndex = 0;
            cursorIndex = 0;

            initBoard();
            startMemorizePhase();
        }

        function initBoard() {
            const pairsCount = cardCount / 2;
            let sourceEmojis = EMOJIS_ANIMALS;
            switch (currentTheme) {
                case 'FACES': sourceEmojis = EMOJIS_FACES; break;
                case 'FRUITS': sourceEmojis = EMOJIS_FRUITS; break;
                case 'VEHICLES': sourceEmojis = EMOJIS_VEHICLES; break;
                case 'JOBS': sourceEmojis = EMOJIS_JOBS; break;
                case 'CLOTHES': sourceEmojis = EMOJIS_CLOTHES; break;
                case 'SPORTS': sourceEmojis = EMOJIS_SPORTS; break;
                default: sourceEmojis = EMOJIS_ANIMALS;
            }

            // Need more emojis if cardCount is high?
            // Arrays have 12. 24 cards = 12 pairs. Max supported is 24 cards.
            const gameEmojis = sourceEmojis.slice(0, pairsCount);
            const cardDeck = [...gameEmojis, ...gameEmojis];

            // Shuffle
            for (let i = cardDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [cardDeck[i], cardDeck[j]] = [cardDeck[j], cardDeck[i]];
            }

            cards = cardDeck.map((emoji, i) => ({
                id: i,
                emoji: emoji,
                flipped: true,
                matched: false
            }));

            // Calculate Grid
            gridCols = Math.ceil(Math.sqrt(cardCount));
            if (cardCount === 12) { gridCols = 4; gridRows = 3; }
            else if (cardCount === 16) { gridCols = 4; gridRows = 4; }
            else if (cardCount === 20) { gridCols = 5; gridRows = 4; }
            else if (cardCount === 24) { gridCols = 6; gridRows = 4; }

            // Create Character
            let charEl = document.getElementById('player-character');
            if (!charEl) {
                charEl = document.createElement('div');
                charEl.id = 'player-character';
                document.getElementById('board-area').appendChild(charEl);
            }

            renderScoreBoard();
            renderGrid();

            // Adjust grid CSS
            const grid = document.getElementById('card-grid');
            grid.style.gridTemplateColumns = `repeat(${gridCols}, 1fr)`;

            // Show character but transparent
            const charElRef = document.getElementById('player-character');
            if (charElRef) {
                charElRef.style.display = 'block';
                charElRef.style.opacity = '0.4';
            }
        }

        function startMemorizePhase() {
            const timerDisplay = document.getElementById('timer-display');
            timerDisplay.classList.remove('hidden');
            let timeLeft = 30;

            renderGrid(true);

            const interval = setInterval(() => {
                if (currentState !== STATE.MEMORIZE) {
                    clearInterval(interval); return;
                }
                timeLeft--;
                timerDisplay.textContent = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(interval);
                    endMemorizePhase();
                }
            }, 1000);

            let charEl = document.getElementById('player-character');
            if (charEl) {
                charEl.style.display = 'block';
                charEl.style.opacity = '0.4';
            }
        }

        function endMemorizePhase() {
            currentState = STATE.PLAY;
            document.getElementById('timer-display').classList.add('hidden');
            let charEl = document.getElementById('player-character');
            if (charEl) charEl.style.opacity = '1';

            cards.forEach(c => c.flipped = false);
            renderGrid();
            updateTurnUI();
        }

        function renderGrid(showAll = false) {
            const grid = document.getElementById('card-grid');
            grid.innerHTML = '';

            // Update CSS grid columns dynamically
            grid.style.gridTemplateColumns = `repeat(${gridCols}, 1fr)`;

            cards.forEach((card, index) => {
                const el = document.createElement('div');
                el.className = `card ${card.flipped || card.matched || showAll ? 'flipped' : ''} ${card.matched ? 'matched' : ''}`;
                if (index === cursorIndex && currentState !== STATE.MENU && currentState !== STATE.GAME_OVER) {
                    el.classList.add('highlight'); // Visual Highlight for Controller/Keyboard
                }

                el.innerHTML = `<div class="card-content">${card.emoji}</div>`;

                el.onclick = () => {
                    // Touch support
                    if (currentState === STATE.PLAY && !isLocked) {
                        cursorIndex = index; // Move cursor to touch
                        updateCharacterPosition(true);
                        selectCard(index);
                    }
                };
                grid.appendChild(el);
            });
        }

        function updateCharacterPosition(animate = false) {
            const charEl = document.getElementById('player-character');
            if (!charEl) return;

            charEl.style.display = 'block';
            if (currentState === STATE.MEMORIZE) {
                charEl.style.opacity = '0.4';
            } else {
                charEl.style.opacity = '1';
            }

            // Assuming character is always present in Play/Memorize

            const grid = document.getElementById('card-grid');
            const cardsEls = grid.querySelectorAll('.card');
            const targetCard = cardsEls[cursorIndex];

            if (targetCard) {
                const boardRect = document.getElementById('board-area').getBoundingClientRect();
                const cardRect = targetCard.getBoundingClientRect();

                const left = cardRect.left - boardRect.left + (cardRect.width / 2) - (charEl.offsetWidth / 2);
                const top = cardRect.top - boardRect.top - 50;

                charEl.style.left = `${left}px`;
                charEl.style.top = `${top}px`;

                const player = activePlayers[currentPlayerIndex];
                charEl.style.color = player.color;
                charEl.innerHTML = `<div class="doll-svg-container">${getAvatarSVG(player.name, false)}</div>`;

                if (animate) {
                    charEl.classList.add('walking');
                    setTimeout(() => charEl.classList.remove('walking'), 300);
                }
            }
        }

        function selectCard(index) {
            const card = cards[index];
            if (card.matched || card.flipped || selectedCards.length >= 2) return;

            SFX.select();
            // Vibro
            const gp = navigator.getGamepads()[gpIndex];
            if (gp?.vibrationActuator) gp.vibrationActuator.playEffect("dual-rumble", { duration: 50, weakMagnitude: 0.2 });

            card.flipped = true;
            selectedCards.push(index);
            renderGrid();

            if (selectedCards.length === 2) {
                checkMatch();
            }
        }

        function checkMatch() {
            isLocked = true;
            const [idx1, idx2] = selectedCards;
            const c1 = cards[idx1];
            const c2 = cards[idx2];

            if (c1.emoji === c2.emoji) {
                // MATCH
                setTimeout(() => {
                    SFX.match();
                    c1.matched = true;
                    c2.matched = true;
                    selectedCards = [];
                    isLocked = false;

                    const player = activePlayers[currentPlayerIndex];
                    player.score++;
                    player.magnets++;

                    // First to 10 Wins Check
                    if (player.score >= 10) {
                        endGameWithWinner(player);
                        return;
                    }

                    // Win Anim
                    const charEl = document.getElementById('player-character');
                    if (charEl) charEl.innerHTML = `<div class="doll-svg-container pop-anim">${getAvatarSVG(player.name, true)}</div>`;

                    triggerConfetti(player.color);
                    renderScoreBoard();
                    renderGrid();
                    checkWin(); // Check if all cards matched

                    setTimeout(() => updateCharacterPosition(false), 500);
                }, 500);
            } else {
                // ERROR
                setTimeout(() => {
                    SFX.error();
                    const gp = navigator.getGamepads()[gpIndex];
                    if (gp?.vibrationActuator) gp.vibrationActuator.playEffect("dual-rumble", { duration: 100, strongMagnitude: 0.5 });

                    c1.flipped = false;
                    c2.flipped = false;
                    selectedCards = [];
                    isLocked = false;

                    nextTurn();
                    renderGrid();
                }, 1500);
            }
        }

        function nextTurn() {
            currentPlayerIndex = (currentPlayerIndex + 1) % activePlayers.length;
            updateTurnUI();
            updateCharacterPosition(true);
        }

        function updateTurnUI() {
            renderScoreBoard();
        }

        function renderScoreBoard() {
            const board = document.getElementById('score-board');
            board.innerHTML = '';
            activePlayers.forEach((p, idx) => {
                const isActive = (idx === currentPlayerIndex && currentState === STATE.PLAY);
                const div = document.createElement('div');
                div.className = `player-score ${isActive ? 'active' : ''}`;
                div.style.color = p.color;
                div.style.borderColor = p.color;

                div.innerHTML = `
                 <div class="avatar" style="width: 40px; height: 40px;">${getAvatarSVG(p.name, false)}</div>
                 <div class="info-col">
                    <div class="name">${p.name} <span style="font-size:0.8rem">üèÜ${p.wins}</span></div>
                    <div class="score">Parejas: ${p.score}</div>
                    <div class="magnets">${renderMagnets(p.magnets)}</div>
                 </div>`;
                board.appendChild(div);
            });
        }

        function renderMagnets(count) {
            let html = '';
            for (let i = 1; i <= 6; i++) {
                let icon = 'üß≤';
                if (i > 3) icon = 'üòàüß≤'; // Bad magnets logic from prev steps
                html += `<span class="magnet ${i <= count ? 'active' : ''}">${icon}</span>`;
            }
            return html;
        }

        function checkWin() {
            if (cards.every(c => c.matched)) {
                // End game normal
                // Determine winner by score
                const sorted = [...activePlayers].sort((a, b) => b.score - a.score);
                endGameWithWinner(sorted[0]);
            }
        }

        function endGameWithWinner(winner) {
            SFX.win();
            currentState = STATE.GAME_OVER;

            // Check tie
            const topScore = winner.score;
            const winners = activePlayers.filter(p => p.score === topScore);

            const gameOverScreen = document.getElementById('game-over-screen');
            gameOverScreen.classList.remove('hidden');
            const winnerDiv = document.getElementById('winner-display');

            if (winners.length > 1) {
                winnerDiv.innerHTML = `¬°Empate! ü§ù<br><div style="font-size:4rem; margin-top:10px">üé≠</div>`;
            } else {
                winner.wins++;
                saveWins();
                winnerDiv.innerHTML = `¬°Ganador: <span style="color:${winner.color}">${winner.name}</span>!<div style="width: 150px; height: 200px; margin: 20px auto; animation: pop 0.5s infinite alternate">${getAvatarSVG(winner.name, true)}</div>`;
                triggerConfetti(winner.color, 200);
            }

            let scoresHtml = '';
            [...activePlayers].sort((a, b) => b.score - a.score).forEach(p => {
                scoresHtml += `<p>${p.name}: ${p.score} Parejas</p>`;
            });
            document.getElementById('final-scores').innerHTML = scoresHtml;
        }

        function resetGame() {
            currentState = STATE.MENU;
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('start-screen').classList.remove('hidden');
            document.getElementById('gamepad-hint').classList.remove('hidden');

            document.getElementById('card-grid').innerHTML = '';
            document.getElementById('score-board').innerHTML = '';
            const char = document.getElementById('player-character');
            if (char) char.remove();

            // Re-init menu logic
            menuSection = 0;
            updateMenuVisuals();
            renderPlayerOptions();
        }

        function triggerConfetti(color, amount = 50) {
            for (let i = 0; i < amount; i++) {
                const c = document.createElement('div');
                c.style.position = 'fixed';
                c.style.left = Math.random() * 100 + 'vw';
                c.style.top = '-10px';
                c.style.width = '10px';
                c.style.height = '10px';
                c.style.backgroundColor = color;
                c.style.transform = `rotate(${Math.random() * 360}deg)`;
                c.style.zIndex = '9999';
                document.body.appendChild(c);

                const anim = c.animate([
                    { transform: `translateY(0) rotate(0)`, opacity: 1 },
                    { transform: `translateY(100vh) rotate(${Math.random() * 720}deg)`, opacity: 0 }
                ], {
                    duration: 2000 + Math.random() * 3000,
                    easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                });

                anim.onfinish = () => c.remove();
            }
        }

        // --- GAMEPAD ---
        let gpIndex = -1;
        let lastButtonState = {};
        let lastAxisState = { x: 0, y: 0 };
        const BTN = { X: 0, CIRCLE: 1, SQUARE: 2, TRIANGLE: 3, L1: 4, R1: 5, L2: 6, R2: 7 };

        window.addEventListener("gamepadconnected", (e) => {
            gpIndex = e.gamepad.index;
            updateGamepadStatus(true, e.gamepad.id);
            console.log("Gamepad connected:", e.gamepad.id);
        });

        window.addEventListener("gamepaddisconnected", (e) => {
            if (gpIndex === e.gamepad.index) {
                gpIndex = -1;
                updateGamepadStatus(false);
            }
        });

        function updateGamepadStatus(connected, id = "") {
            const hint = document.getElementById('gamepad-hint');
            if (connected) {
                hint.innerHTML = `<span style="color:#4ade80">‚úî Mando Conectado</span>`;
                hint.style.borderColor = "#4ade80";
            } else {
                hint.innerHTML = `<span>‚ö†Ô∏è Presiona cualquier bot√≥n...</span>`;
                hint.style.borderColor = "white";
            }
        }

        function pollGamepad() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            let gp = gamepads[gpIndex];

            if (!gp) { // Search
                for (let i = 0; i < gamepads.length; i++) {
                    if (gamepads[i]) { gpIndex = i; gp = gamepads[i]; updateGamepadStatus(true, gp.id); break; }
                }
            }
            if (!gp) return;

            // Buttons
            const isPressed = (b) => {
                if (!gp.buttons[b]) return false;
                const pressed = gp.buttons[b].pressed;
                if (pressed && !lastButtonState[b]) { lastButtonState[b] = true; return true; }
                if (!pressed) lastButtonState[b] = false;
                return false;
            };

            // Axes
            let dx = 0; let dy = 0;
            if (Math.abs(gp.axes[0]) > 0.5) dx = Math.sign(gp.axes[0]);
            if (Math.abs(gp.axes[1]) > 0.5) dy = Math.sign(gp.axes[1]);
            // D-pad
            if (gp.buttons[12]?.pressed) dy = -1;
            if (gp.buttons[13]?.pressed) dy = 1;
            if (gp.buttons[14]?.pressed) dx = -1;
            if (gp.buttons[15]?.pressed) dx = 1;

            if (dx !== 0 && lastAxisState.x === 0) handleInput('move', dx, 0);
            if (dy !== 0 && lastAxisState.y === 0) handleInput('move', 0, dy);
            lastAxisState.x = dx;
            lastAxisState.y = dy;

            if (isPressed(BTN.X)) handleInput('action');
            if (isPressed(BTN.CIRCLE)) handleInput('back');
            if (isPressed(BTN.TRIANGLE)) handleInput('reset');
            if (isPressed(BTN.SQUARE)) handleInput('remove');
            if (isPressed(BTN.L1)) handleInput('prevColor');
            if (isPressed(BTN.R1)) handleInput('nextColor');
            if (isPressed(BTN.L2)) handleInput('cycleShape');
            if (isPressed(BTN.R2)) handleInput('toggleEraser');
        }

        // --- NAVIGATION ---
        function openGame(game) {
            APP_MODE = game;
            document.getElementById('main-menu').classList.add('hidden');
            document.querySelectorAll('.game-wrapper').forEach(el => el.classList.add('hidden'));

            if (game === 'MEMORY') {
                document.getElementById('memory-game-wrapper').classList.remove('hidden');
                resetGame();
            } else if (game === 'SIMON') {
                currentState = STATE.SIMON;
                document.getElementById('simon-game-wrapper').classList.remove('hidden');
            } else if (game === 'WHACK') {
                currentState = STATE.WHACK;
                document.getElementById('whack-game-wrapper').classList.remove('hidden');
            } else if (game === 'BUILDER') {
                currentState = STATE.BUILDER;
                document.getElementById('builder-game-wrapper').classList.remove('hidden');
                initBuilderGame();
            }
        }

        function goToMainMenu() {
            APP_MODE = 'MENU';
            currentState = STATE.HUB;
            hubSelectionIndex = 0;
            updateHubVisuals();

            document.querySelectorAll('.game-wrapper').forEach(el => el.classList.add('hidden'));
            document.getElementById('main-menu').classList.remove('hidden');

            // cleanup
            if (typeof whackTimerInterval !== 'undefined') clearInterval(whackTimerInterval);
        }

        function handleInput(type, dx, dy) {
            if (type === 'back') { goToMainMenu(); return; }

            if (currentState === STATE.HUB) handleHubInput(type, dx, dy);
            else if (currentState === STATE.MENU) handleMenuInput(type, dx, dy);
            else if (currentState === STATE.PLAY || currentState === STATE.MEMORIZE) handleGameInput(type, dx, dy);
            else if (currentState === STATE.BUILDER) handleBuilderInput(type, dx, dy);
            else if (currentState === STATE.GAME_OVER && type === 'action') resetGame();
        }

        function handleHubInput(type, dx, dy) {
            if (type === 'move') {
                const old = hubSelectionIndex;
                if (dx > 0 || dy > 0) hubSelectionIndex = Math.min(3, hubSelectionIndex + 1); // 4 games
                if (dx < 0 || dy < 0) hubSelectionIndex = Math.max(0, hubSelectionIndex - 1);
                if (old !== hubSelectionIndex) {
                    SFX.move();
                    updateHubVisuals();
                }
            }
            if (type === 'action') {
                SFX.select();
                const games = ['MEMORY', 'SIMON', 'WHACK', 'BUILDER'];
                openGame(games[hubSelectionIndex]);
            }
        }

        function updateHubVisuals() {
            document.querySelectorAll('.game-card').forEach((el, idx) => {
                if (idx === hubSelectionIndex) {
                    el.style.transform = "scale(1.1)";
                    el.style.borderColor = "#fff";
                    el.style.borderWidth = "4px";
                    el.style.borderStyle = "solid";
                    el.style.boxShadow = "0 0 20px white";
                    el.style.zIndex = "10";
                } else {
                    el.style.transform = "scale(1)";
                    el.style.borderColor = "transparent";
                    el.style.borderWidth = "0px";
                    el.style.boxShadow = "none";
                    el.style.zIndex = "1";
                }
            });
        }

        function handleGameInput(type, dx, dy) {
            if (type === 'move') {
                // Grid movement
                if (dx !== 0) {
                    cursorIndex += dx;
                    if (cursorIndex < 0) cursorIndex = 0; // Simple clamp, row wrapping allowed
                    if (cursorIndex >= cards.length) cursorIndex = cards.length - 1;
                }
                if (dy !== 0) {
                    const newIdx = cursorIndex + (dy * gridCols);
                    if (newIdx >= 0 && newIdx < cards.length) cursorIndex = newIdx;
                }
                SFX.move();
                renderGrid();
                updateCharacterPosition(true);
            }
            if (type === 'action' && currentState === STATE.PLAY && !isLocked) {
                selectCard(cursorIndex);
            }
        }

        // --- SIMON GAME LOGIC ---
        let simonSequence = [];
        let simonPlayerInput = [];
        let simonRound = 0;
        let simonLocked = false;

        const SIMON_SOUNDS = [
            261.63, // C4 (Green)
            329.63, // E4 (Red)
            392.00, // G4 (Yellow)
            523.25  // C5 (Blue)
        ];

        function playSimonTone(index) {
            const o = new AudioContext();
            const g = o.createGain();
            const osc = o.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(SIMON_SOUNDS[index], o.currentTime);
            g.gain.setValueAtTime(0.1, o.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, o.currentTime + 0.3);
            osc.connect(g);
            g.connect(o.destination);
            osc.start();
            osc.stop(o.currentTime + 0.3);
        }

        function flashSimonButton(index) {
            const btn = document.querySelector(`.simon-btn[data-color="${index}"]`);
            if (btn) {
                btn.classList.add('active');
                playSimonTone(index);
                setTimeout(() => btn.classList.remove('active'), 300);
            }
        }

        function startSimonGame() {
            simonSequence = [];
            simonRound = 0;
            simonLocked = true;
            document.getElementById('simon-status').textContent = "¬°Atenci√≥n!";
            setTimeout(nextSimonRound, 1000);
        }

        function nextSimonRound() {
            simonRound++;
            simonPlayerInput = [];
            document.getElementById('simon-status').textContent = `Nivel ${simonRound}`;

            // Add random step
            simonSequence.push(Math.floor(Math.random() * 4));

            // Play sequence
            simonLocked = true;
            let i = 0;
            const interval = setInterval(() => {
                flashSimonButton(simonSequence[i]);
                i++;
                if (i >= simonSequence.length) {
                    clearInterval(interval);
                    simonLocked = false;
                    document.getElementById('simon-status').textContent = "¬°Tu turno!";
                }
            }, 800);
        }

        function handleSimonInput(index) {
            if (simonLocked || APP_MODE !== 'SIMON') return;

            flashSimonButton(index);
            simonPlayerInput.push(index);

            // Check correctness
            const currentStep = simonPlayerInput.length - 1;
            if (simonPlayerInput[currentStep] !== simonSequence[currentStep]) {
                document.getElementById('simon-status').textContent = "‚ùå ¬°Oh no! Intenta otra vez.";
                SFX.error();
                simonLocked = true;
                return;
            }

            if (simonPlayerInput.length === simonSequence.length) {
                // Round Complete
                simonLocked = true;
                setTimeout(nextSimonRound, 1000);
            }
        }

        // --- WHACK GAME LOGIC ---
        let whackScore = 0;
        let whackTime = 30;
        let lastHole;
        let whackGameOver = false;
        let whackTimerInterval;

        function randomTime(min, max) {
            return Math.round(Math.random() * (max - min) + min);
        }

        function randomHole(holes) {
            const idx = Math.floor(Math.random() * holes.length);
            const hole = holes[idx];
            if (hole === lastHole) return randomHole(holes);
            lastHole = hole;
            return hole;
        }

        function peep() {
            if (whackGameOver || APP_MODE !== 'WHACK') return;
            const time = randomTime(600, 1200);
            const holes = document.querySelectorAll('.hole');
            const hole = randomHole(holes);
            const mole = hole.querySelector('.mole');

            // Random Avatar
            const randomPlayer = PLAYERS[Math.floor(Math.random() * PLAYERS.length)];
            mole.innerHTML = getAvatarSVG(randomPlayer.name, false);

            mole.classList.add('up');

            setTimeout(() => {
                mole.classList.remove('up');
                if (!whackGameOver && APP_MODE === 'WHACK') peep();
            }, time);
        }

        function startWhackGame() {
            whackScore = 0;
            whackTime = 30;
            whackGameOver = false;
            document.getElementById('whack-score').textContent = 0;
            document.getElementById('whack-timer').textContent = 30;

            // Attach Click Listeners
            document.querySelectorAll('.mole').forEach(mole => {
                mole.onclick = function () {
                    if (!this.classList.contains('up')) return;
                    whackScore++;
                    this.classList.remove('up');
                    document.getElementById('whack-score').textContent = whackScore;
                    SFX.select();
                    if (navigator.vibrate) navigator.vibrate(20);
                };
            });

            whackTimerInterval = setInterval(() => {
                if (APP_MODE !== 'WHACK') { clearInterval(whackTimerInterval); return; }
                whackTime--;
                document.getElementById('whack-timer').textContent = whackTime;
                if (whackTime <= 0) {
                    endWhackGame();
                }
            }, 1000);

            peep();
        }

        function endWhackGame() {
            whackGameOver = true;
            clearInterval(whackTimerInterval);
            // Hide all moles
            document.querySelectorAll('.mole').forEach(m => m.classList.remove('up'));

            SFX.win();
            // Reuse Memory Game Over screen or simple alert for now
            // Just modifying the header temporarily
            const originalHeader = document.querySelector('#whack-game-wrapper h1').textContent;
            document.querySelector('#whack-game-wrapper h1').textContent = `¬°Fin! Puntos: ${whackScore}`;
            setTimeout(() => {
                document.querySelector('#whack-game-wrapper h1').textContent = originalHeader; // Reset
            }, 3000);
        }

        // --- BUILDER GAME LOGIC ---
        let builderGrid = []; // 10x10
        const BUILDER_SIZE = 10;
        const BUILDER_COLORS = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#a855f7', '#ec4899', '#ffffff', '#000000', '#9ca3af'];
        let currentBuilderColor = BUILDER_COLORS[0];
        let currentBuilderShape = '1x1'; // 1x1, 1x2, 2x2
        let builderTool = 'brush'; // 'brush' or 'eraser'
        let builderCursor = { x: 0, y: 0 };

        // Blueprints
        let currentBlueprintIndex = 0;
        const BLUEPRINTS = [
            { name: "Libre", grid: null },
            {
                name: "Mario", grid: [
                    [null, null, "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", null, null, null],
                    [null, null, "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", null],
                    [null, null, "#8D6E63", "#8D6E63", "#8D6E63", "#000000", "#000000", "#8D6E63", null, null],
                    [null, "#8D6E63", "#8D6E63", "#8D6E63", "#8D6E63", "#000000", "#000000", "#000000", "#8D6E63", null],
                    [null, "#8D6E63", "#8D6E63", "#8D6E63", "#8D6E63", "#8D6E63", "#8D6E63", "#8D6E63", null, null],
                    [null, null, "#ef4444", "#ef4444", "#ef4444", "#ef4444", null, null, null, null],
                    [null, "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", null, null, null, null],
                    [null, null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null, null]
                ]
            },
            {
                name: "Espada", grid: [
                    [null, null, null, null, "#9ca3af", null, null, null, null, null],
                    [null, null, null, "#9ca3af", "#9ca3af", "#9ca3af", null, null, null, null],
                    [null, null, null, "#9ca3af", "#9ca3af", "#9ca3af", null, null, null, null],
                    [null, null, null, "#9ca3af", "#9ca3af", "#9ca3af", null, null, null, null],
                    [null, null, null, "#9ca3af", "#9ca3af", "#9ca3af", null, null, null, null],
                    [null, null, "#f97316", "#f97316", "#f97316", "#f97316", "#f97316", null, null, null],
                    [null, null, null, null, "#f97316", null, null, null, null, null],
                    [null, null, null, null, "#f97316", null, null, null, null, null],
                    [null, null, null, null, "#f97316", null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null, null]
                ]
            },
            {
                name: "Coraz√≥n", grid: [
                    [null, null, "#ef4444", "#ef4444", null, null, "#ef4444", "#ef4444", null, null],
                    [null, "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", null],
                    [null, "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", null],
                    [null, "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", null],
                    [null, null, "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", "#ef4444", null, null],
                    [null, null, null, "#ef4444", "#ef4444", "#ef4444", "#ef4444", null, null, null],
                    [null, null, null, null, "#ef4444", "#ef4444", null, null, null, null],
                    [null, null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null, null]
                ]
            },
            {
                name: "Pato", grid: [
                    [null, null, null, null, null, "#eab308", "#eab308", null, null, null],
                    [null, null, null, null, "#eab308", "#eab308", "#eab308", null, null, null],
                    [null, null, null, "#f97316", "#eab308", "#000000", "#eab308", null, null, null],
                    [null, null, "#eab308", "#eab308", "#eab308", "#eab308", "#eab308", null, null, null],
                    [null, "#eab308", "#eab308", "#eab308", "#eab308", "#eab308", "#eab308", null, null, null],
                    [null, "#eab308", "#eab308", "#eab308", "#eab308", "#eab308", "#eab308", null, null, null],
                    [null, null, "#eab308", "#eab308", "#eab308", "#eab308", null, null, null, null],
                    [null, null, "#f97316", "#f97316", null, "#f97316", "#f97316", null, null, null],
                    [null, null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null, null]
                ]
            },
            {
                name: "Flor", grid: [
                    [null, null, null, "#ec4899", "#ec4899", null, null, null, null, null],
                    [null, null, "#ec4899", "#eab308", "#eab308", "#ec4899", null, null, null, null],
                    [null, null, "#ec4899", "#eab308", "#eab308", "#ec4899", null, null, null, null],
                    [null, null, null, "#ec4899", "#ec4899", null, null, null, null, null],
                    [null, null, null, null, "#22c55e", null, null, null, null, null],
                    [null, null, null, "#22c55e", "#22c55e", "#22c55e", null, null, null, null],
                    [null, null, null, null, "#22c55e", null, null, null, null, null],
                    [null, null, null, null, "#22c55e", null, null, null, null, null],
                    [null, null, null, "#8D6E63", "#8D6E63", "#8D6E63", null, null, null, null],
                    [null, null, null, null, null, null, null, null, null, null]
                ]
            }
        ];

        function initBuilderGame() {
            builderCursor = { x: 0, y: 0 }; // Reset cursor
            // Load Blueprint logic
            currentBlueprintIndex = 0;
            loadBlueprint(0);

            renderBuilderPalette();
            renderBuilderGrid();
            document.getElementById('builder-msg').textContent = "Usa el mando o toca para construir";
        }

        function loadBlueprint(idx) {
            currentBlueprintIndex = idx;
            const bp = BLUEPRINTS[idx];
            document.getElementById('blueprint-name').textContent = bp.name;

            // Render Preview
            const preview = document.getElementById('blueprint-preview');
            // Force reset preview style in case it was simplified
            preview.style.display = "grid";
            preview.style.alignItems = "stretch";
            preview.style.justifyContent = "stretch";
            preview.innerHTML = '';

            // Clear current grid for new challenge
            clearBuilder(true);

            if (bp.grid) {
                for (let y = 0; y < BUILDER_SIZE; y++) {
                    for (let x = 0; x < BUILDER_SIZE; x++) {
                        const d = document.createElement('div');
                        d.style.width = '100%';
                        d.style.height = '100%';
                        if (bp.grid[y][x]) d.style.backgroundColor = bp.grid[y][x];
                        preview.appendChild(d);
                    }
                }
            } else {
                preview.textContent = "‚ùì";
                preview.style.display = "flex";
                preview.style.alignItems = "center";
                preview.style.justifyContent = "center";
                preview.style.fontSize = "30px";
            }
        }

        function nextBlueprint() {
            let idx = (currentBlueprintIndex + 1) % BLUEPRINTS.length;
            loadBlueprint(idx);
            SFX.select();
        }

        function prevBlueprint() {
            let idx = (currentBlueprintIndex - 1 + BLUEPRINTS.length) % BLUEPRINTS.length;
            loadBlueprint(idx);
            SFX.select();
        }

        function checkBlueprint() {
            const bp = BLUEPRINTS[currentBlueprintIndex];
            if (!bp.grid) {
                document.getElementById('builder-msg').textContent = "Modo Libre - ¬°Construye lo que quieras!";
                return;
            }

            let match = true;
            for (let y = 0; y < BUILDER_SIZE; y++) {
                for (let x = 0; x < BUILDER_SIZE; x++) {
                    // Treat null and undefined as same?
                    const userCell = builderGrid[y][x];
                    const targetCell = bp.grid[y][x];

                    // Simple check: exact color match
                    if (userCell !== targetCell) {
                        // Allow null vs null
                        if (!userCell && !targetCell) continue;
                        match = false;
                        break;
                    }
                }
            }

            if (match) {
                document.getElementById('builder-msg').textContent = "¬°Incre√≠ble! ¬°Lo has logrado! üéâ";
                SFX.win();
                triggerConfetti('gold');
            } else {
                document.getElementById('builder-msg').textContent = "Mmm... algo no coincide. ¬°Sigue intentando!";
                SFX.error();
            }
        }

        function clearBuilder(render = true) {
            builderGrid = Array(BUILDER_SIZE).fill(null).map(() => Array(BUILDER_SIZE).fill(null));
            if (render) {
                renderBuilderGrid();
                SFX.error(); // Recycle sound for delete
            }
        }

        function saveBuilder() {
            localStorage.setItem('builder_grid', JSON.stringify(builderGrid));
            document.getElementById('builder-msg').textContent = "¬°Guardado! üíæ";
            SFX.win();
            setTimeout(() => document.getElementById('builder-msg').textContent = "", 2000);
        }

        function renderBuilderPalette() {
            const p = document.getElementById('builder-palette');
            p.innerHTML = '';

            // Eraser Tool
            const eraser = document.createElement('div');
            eraser.className = 'palette-color';
            eraser.style.background = 'white';
            eraser.style.border = '2px dashed #333';
            eraser.innerText = 'üßº';
            eraser.style.display = 'flex';
            eraser.style.justifyContent = 'center';
            eraser.style.alignItems = 'center';
            eraser.style.fontSize = '20px';
            if (builderTool === 'eraser') eraser.classList.add('selected');
            eraser.onclick = () => { builderTool = 'eraser'; SFX.select(); renderBuilderPalette(); };
            p.appendChild(eraser);

            // Shape Toggles
            const shapesDiv = document.createElement('div');
            shapesDiv.style.display = 'flex';
            shapesDiv.style.gap = '5px';
            shapesDiv.style.marginBottom = '10px';
            ['1x1', '1x2', '2x2'].forEach(s => {
                const btn = document.createElement('button');
                btn.innerText = s;
                btn.style.padding = '2px 5px';
                btn.style.fontSize = '0.7rem';
                btn.style.border = currentBuilderShape === s ? '2px solid #333' : '1px solid #ccc';
                btn.style.background = currentBuilderShape === s ? '#eab308' : 'white';
                btn.onclick = () => { currentBuilderShape = s; SFX.select(); renderBuilderPalette(); };
                shapesDiv.appendChild(btn);
            });
            p.appendChild(shapesDiv);

            BUILDER_COLORS.forEach(c => {
                const div = document.createElement('div');
                div.className = 'palette-color';
                div.style.backgroundColor = c;
                if (c === currentBuilderColor && builderTool === 'brush') div.classList.add('selected');
                div.onclick = () => { selectBuilderColor(c); };
                p.appendChild(div);
            });
        }

        function selectBuilderColor(c) {
            currentBuilderColor = c;
            builderTool = 'brush';
            SFX.select();
            renderBuilderPalette();
        }

        function applyBuilderAction(tx, ty) {
            const color = builderTool === 'eraser' ? null : currentBuilderColor;

            // 1x1
            if (currentBuilderShape === '1x1') {
                if (tx >= 0 && tx < BUILDER_SIZE && ty >= 0 && ty < BUILDER_SIZE) {
                    builderGrid[ty][tx] = color;
                }
            }
            // 1x2 (Horizontal)
            else if (currentBuilderShape === '1x2') {
                if (tx >= 0 && tx < BUILDER_SIZE && ty >= 0 && ty < BUILDER_SIZE) builderGrid[ty][tx] = color;
                if (tx + 1 < BUILDER_SIZE && ty >= 0 && ty < BUILDER_SIZE) builderGrid[ty][tx + 1] = color;
            }
            // 2x2
            else if (currentBuilderShape === '2x2') {
                if (tx >= 0 && tx < BUILDER_SIZE && ty >= 0 && ty < BUILDER_SIZE) builderGrid[ty][tx] = color;
                if (tx + 1 < BUILDER_SIZE && ty >= 0 && ty < BUILDER_SIZE) builderGrid[ty][tx + 1] = color;
                if (tx >= 0 && tx < BUILDER_SIZE && ty + 1 < BUILDER_SIZE) builderGrid[ty + 1][tx] = color;
                if (tx + 1 < BUILDER_SIZE && ty + 1 < BUILDER_SIZE) builderGrid[ty + 1][tx + 1] = color;
            }
            renderBuilderGrid();
            SFX.select();
        }

        function renderBuilderGrid() {
            const c = document.getElementById('builder-canvas');
            c.innerHTML = '';
            for (let y = 0; y < BUILDER_SIZE; y++) {
                for (let x = 0; x < BUILDER_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'build-cell';
                    if (builderGrid[y][x]) {
                        cell.style.backgroundColor = builderGrid[y][x];
                        cell.classList.add('filled');
                    }

                    // Gamepad Cursor
                    if (currentState === STATE.BUILDER) {
                        // Check if this cell is part of the cursor shape
                        let isCursor = false;
                        const bx = builderCursor.x;
                        const by = builderCursor.y;

                        if (currentBuilderShape === '1x1' && x === bx && y === by) isCursor = true;
                        if (currentBuilderShape === '1x2' && ((x === bx && y === by) || (x === bx + 1 && y === by))) isCursor = true;
                        if (currentBuilderShape === '2x2' && ((x === bx && y === by) || (x === bx + 1 && y === by) || (x === bx && y === by + 1) || (x === bx + 1 && y === by + 1))) isCursor = true;

                        if (isCursor) {
                            cell.style.border = "3px solid #333";
                            cell.style.transform = "scale(1.1)";
                            cell.style.zIndex = "10";
                            cell.style.boxShadow = "none"; // Remove 3D shadow for cursor to look cleaner
                        }
                    }

                    // Touch Interaction
                    cell.onclick = () => {
                        applyBuilderAction(x, y);
                    };

                    c.appendChild(cell);
                }
            }
        }

        function handleBuilderInput(type, dx, dy) {
            if (type === 'move') {
                const oldX = builderCursor.x;
                const oldY = builderCursor.y;
                builderCursor.x = Math.max(0, Math.min(BUILDER_SIZE - 1, builderCursor.x + dx));
                builderCursor.y = Math.max(0, Math.min(BUILDER_SIZE - 1, builderCursor.y + dy));

                if (oldX !== builderCursor.x || oldY !== builderCursor.y) {
                    SFX.move();
                    renderBuilderGrid();
                }
            }
            if (type === 'action') { // X - Place/Erase (depends on tool)
                applyBuilderAction(builderCursor.x, builderCursor.y);
            }
            if (type === 'remove') { // Square - Quick Eraser (Force 1x1 erase)
                const oldTool = builderTool;
                builderTool = 'eraser';
                const oldShape = currentBuilderShape;
                currentBuilderShape = '1x1'; // Precision erase
                applyBuilderAction(builderCursor.x, builderCursor.y);
                builderTool = oldTool;
                currentBuilderShape = oldShape;
            }
            if (type === 'prevColor' || type === 'nextColor') {
                let idx = BUILDER_COLORS.indexOf(currentBuilderColor);
                if (type === 'nextColor') idx = (idx + 1) % BUILDER_COLORS.length;
                if (type === 'prevColor') idx = (idx - 1 + BUILDER_COLORS.length) % BUILDER_COLORS.length;
                selectBuilderColor(BUILDER_COLORS[idx]);
            }
            if (type === 'reset') { // Triangle - Check
                checkBlueprint();
            }
            if (type === 'cycleShape') { // L2
                const shapes = ['1x1', '1x2', '2x2'];
                const idx = (shapes.indexOf(currentBuilderShape) + 1) % shapes.length;
                currentBuilderShape = shapes[idx];
                renderBuilderPalette();
                SFX.select();
            }
            if (type === 'toggleEraser') { // R2
                if (builderTool === 'eraser') {
                    builderTool = 'brush'; // Toggle off
                } else {
                    builderTool = 'eraser';
                }
                renderBuilderPalette();
                SFX.select();
            }
            if (type === 'back') {
                goToMainMenu();
            }
        }

        // --- RACE GAME LOGIC ---














        // --- KEYBOARD ---
        window.addEventListener('keydown', (e) => {
            let handled = false;



            if (e.key === 'ArrowRight') { handleInput('move', 1, 0); handled = true; }
            if (e.key === 'ArrowLeft') { handleInput('move', -1, 0); handled = true; }
            if (e.key === 'ArrowDown') { handleInput('move', 0, 1); handled = true; }
            if (e.key === 'ArrowUp') { handleInput('move', 0, -1); handled = true; }
            if (e.key === 'Enter' || e.key === ' ') { handleInput('action'); handled = true; }
            if (handled) e.preventDefault();
        });

        // --- LOOP ---
        function gameLoop() {
            pollGamepad();
            requestAnimationFrame(gameLoop);
        }

        // Init
        renderPlayerOptions();
        updateMenuVisuals();
        updateHubVisuals();
        gameLoop();

    </script>
</body>

</html>